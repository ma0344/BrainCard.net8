using BrainCard.ViewModels;
using ModernWpf;
using MyUWPApp;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using System.Runtime.Serialization;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Threading;
using Windows.Storage.Streams;
using Windows.UI.Input.Inking;
using static BrainCard.Values;
using forms = System.Windows.Forms;
using ui = ModernWpf.Controls;



namespace BrainCard
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        public EventHandler CardsLoaded;
        private readonly ObservableCollection<Card> CardList;
        private readonly SubWindow subWindow;
        public MainWindowViewModel vm;
        public Card EditingCard;
        // カード : 選択中のカード
        private Card currentCard;
        // カード : 最終追加時の位置情報
        private double lastImagePositionLeft = 0;
        private double lastImagePositionTop = 10;
        private int currentZIndex = 0;
        public int selectedCardZIndex;

        private bool cardCanvasToggleSwitchLastState_IsOn;
        public Point originalSubWindowPos;
        private Point _dragStartPoint;
        private InsertionAdorner _insertionAdorner;
        private DispatcherTimer StatusBarMessageClearTimer;
        private bool isWheelScaling = false;
        private Point mouseCanvasPos = new Point();
        private double oldScale = 0;

        private bool isDragging = false;
        private Point dragStartPoint;
        private double startOffsetX;
        private double startOffsetY;

        // ロード処理の多重実行を防ぐための排他制御
        private readonly SemaphoreSlim _loadSemaphore = new SemaphoreSlim(1, 1);

        public MainWindow(string[] args = null)
        {
            InitializeComponent();

            vm = new MainWindowViewModel();
            vm.PropertyChanged += Vm_PropertyChanged;
            DataContext = vm;

            // Initialize file state via ViewModel (Title is bound to vm.WindowTitle).
            if (args != null && args.Length > 0)
            {
                vm.CurrentFileName = args[0];
                vm.IsNewFile = false;
            }
            else
            {
                vm.CurrentFileName = "Untitled.bcf";
                vm.IsNewFile = true;
            }

            subWindow = new SubWindow(this);
            CardList = new ObservableCollection<Card>();
            vm.CardList = CardList;

            this.Loaded += MainWindow_Loaded;
            this.Closed += MainWindow_Closed;
            this.CardsLoaded += MainWindow_CardsLoaded;
            subWindow.ContentRendered += SubWindow_ContentRendered;
            CanvasColorPickerButton.ColorChanged += ColorPicker_SelectedColorChanged;
            MainCanvasGrid.MouseLeftButtonDown += MainCanvasGrid_MouseLeftButtonDown;
            MainCanvasGrid.MouseLeftButtonUp += MainCanvasGrid_MouseLeftButtonUp;
            MainCanvasGrid.MouseWheel += MainCanvasGrid_MouseWheel;
            MainScrollViewer.MouseMove += MainScrollViewer_MouseMove;
            MainScrollViewer.MouseLeftButtonDown += MainCanvasGrid_MouseLeftButtonDown;
            MainScrollViewer.MouseLeftButtonUp += MainCanvasGrid_MouseLeftButtonUp;

            MainScrollViewer.PreviewMouseWheel += MainCanvasGrid_MouseWheel;

            KeyDown += MainWindow_KeyDown;
            Touch.FrameReported += Touch_FrameReported;

        }

        private void MainScrollViewer_MouseMove(object sender, MouseEventArgs e)
        {
            if (isDragging && e.LeftButton == MouseButtonState.Pressed)
            {
                Point currentPos = e.GetPosition(null);
                double dx = currentPos.X - dragStartPoint.X;
                double dy = currentPos.Y - dragStartPoint.Y;

                MainScrollViewer.ScrollToHorizontalOffset(startOffsetX - dx);
                MainScrollViewer.ScrollToVerticalOffset(startOffsetY - dy);
            }

        }


        private void SubWindow_ContentRendered(object sender, EventArgs e)
        {
            if (vm != null && !vm.IsNewFile)
            {
                _ = LoadStateAsync(vm.CurrentFileName);
            }
        }

        private void MainWindow_KeyDown(object sender, KeyEventArgs e)
        {
            // ロード中は入力を無視
            if (vm?.IsLoading == true) return;

            switch (e.Key)
            {
                case Key.Delete:
                    if (currentCard != null)
                    {
                        Card_Delete(currentCard, EventArgs.Empty);
                    }
                    break;
            }
        }

        private void MainCanvasGrid_MouseWheel(object sender, MouseWheelEventArgs e)
        {
            // ロード中は入力を無視
            if (vm?.IsLoading == true) return;

            if (Keyboard.IsKeyDown(Key.LeftCtrl) || Keyboard.IsKeyDown(Key.RightCtrl))
            {
                isWheelScaling = true;
                mouseCanvasPos = e.GetPosition(MainCanvas);
                mouseCanvasPos = e.GetPosition(MainCanvas);
                oldScale = ImageScaleSlider.Value / 100;
                ImageScaleSlider.Value += e.Delta > 0 ? 10 : -10;

                e.Handled = true;
            }
            else if (Keyboard.IsKeyDown(Key.LeftShift) || Keyboard.IsKeyDown(Key.RightShift))
            {
                var offset = e.Delta > 0 ? 80 : -80;
                MainScrollViewer.ScrollToHorizontalOffset(MainScrollViewer.HorizontalOffset + offset);
                e.Handled = true;
            }
        }

        private void MainCanvasGrid_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        {
            // ロード中はドラッグ状態を解除して終了
            if (vm?.IsLoading == true)
            {
                isDragging = false;
                Mouse.Capture(null);
                return;
            }

            _dragStartPoint = e.GetPosition(MainCanvasGrid);
            isDragging = false;
            Mouse.Capture(null);

        }

        private void MainCanvasGrid_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            // ロード中は入力を無視
            if (vm?.IsLoading == true) return;

            DeselectCard();
            CardsListView.SelectedItem = null;
            if(HamburgerMenuPin.IsChecked != true)
            {
                SplitView.IsPaneOpen = false;
                MainScrollViewer.Margin = new Thickness(0);
            }
            isDragging = true;
            dragStartPoint = e.GetPosition(null);
            startOffsetX = MainScrollViewer.HorizontalOffset;
            startOffsetY = MainScrollViewer.VerticalOffset;
            Mouse.Capture(MainCanvasGrid);

        }

        // MainWindow : ロードされたときに呼び出されるメソッド
        private void MainWindow_Loaded(object sender, RoutedEventArgs e)
        {
            vm.IsInEditMode = false;
            OverrayGrid.Visibility = Visibility.Collapsed;
            subWindow.Show();
            subWindow.Owner = this;

        }

        // MainWindow : 閉じるときに呼び出されるメソッド
        private void MainWindow_Closed(object sender, EventArgs e)
        {
            // サブウィンドウを閉じる
            subWindow.Close();

            if (vm != null)
            {
                vm.PropertyChanged -= Vm_PropertyChanged;
            }
        }

        // フロントボタン : クリックしたときの処理
        private void BackButton_Click(object sender, RoutedEventArgs e)
        {
            ChangeZIndex(currentCard, -1);
        }

        // バックボタン : クリックしたときの処理
        private void FrontButton_Click(object sender, RoutedEventArgs e)
        {
            ChangeZIndex(currentCard, 1);
        }

        // カード : Zインデックスをdirection分変更
        private void ChangeZIndex(Card card, int direction)
        {
            if (card == null) return;
            int currentZIndex = Canvas.GetZIndex(card);
            currentCard = card;  //CardList.FirstOrDefault(info => info.Element == element);

            // Z インデックスの上限または下限に達している場合は早期リターン
            if
                (
                direction > 0 && currentZIndex == CardList.Max(card => card.Z)
                ||
                direction < 0 && currentZIndex == CardList.Min(card => card.Z)
                )
                return;

            int newZIndex = currentZIndex + direction;
            Card targetCard = CardList.FirstOrDefault(card => card.Z == newZIndex);


            if (currentCard != null && targetCard != null)
            {
                currentCard.Z += direction;
                targetCard.Z -= direction;
                //                UpdateCardsList();
            }
            //SortCardListByZIndex();
            //            CardsListView.Items.Refresh();
        }

        // カード : カードをメインキャンバスに追加
        public Card AddCard(CustomInkCanvas customInkCanvas, ImageSource imageSource, string recogText, double positionLeft = double.NaN, double positionTop = double.NaN, AddMode addMode = AddMode.Cleate)
        {
            if (double.IsNaN(lastImagePositionLeft)) lastImagePositionLeft = 0;
            if (double.IsNaN(lastImagePositionTop)) lastImagePositionTop = 0;

            double actualWidth = customInkCanvas.InnerInkCanvas.ActualWidth;
            double actualHeight = customInkCanvas.InnerInkCanvas.ActualHeight;

            double scaleX = cardWidth / actualWidth;
            double scaleY = cardHeight / actualHeight;
            float scaleFactor = (float)((scaleX + scaleY) / 2);

            // ストロークをデータ（UI 要素ではなく）としてクローンします。XAML Islands 内でさらに UWP の XAML 要素を生成しないようにするためです。
            InkStrokeContainer strokesToApply = customInkCanvas.CloneStrokeContainer();

            if (addMode == AddMode.Load)
            {
                var scaledContainer = new InkStrokeContainer();
                foreach (var stroke in strokesToApply.GetStrokes())
                {
                    scaledContainer.AddStroke(TransformInkStroke(stroke, scaleFactor));
                }
                strokesToApply = scaledContainer;
            }

            Card card = new Card(this, customInkCanvas, imageSource) { Z = currentZIndex };
            currentZIndex++;

            foreach (var stroke in strokesToApply.GetStrokes())
            {
                customInkCanvas.InnerPresenter.StrokeContainer.AddStroke(stroke.Clone());
            }

            //カードのプロパティを設定
            card.SetText(recogText);
            card.CardPresenter.InputDeviceTypes = Windows.UI.Core.CoreInputDeviceTypes.None;
            
            //カードの位置を設定
            card.Left = !double.IsNaN(positionLeft) ? positionLeft : lastImagePositionLeft;
            card.Top = !double.IsNaN(positionTop) ? positionTop : lastImagePositionTop;
            Canvas.SetZIndex(card, card.Z);
            Canvas.SetLeft(card, card.Left);
            Canvas.SetTop(card, card.Top);

            //カードのイベントを設定
            card.CardClicked += Card_Clicked;
            card.CardSelected += Card_CardSelected;
            card.CardDraging += Card_CardDraging;
            card.EditRequested += Card_EditRequested;
            card.DeleteRequested += Card_DeleteRequested;
            card.CardDragCompleated += Card_CardDragCompleated;
            

            MainCanvas.Children.Add(card);
            CardList.Add(card);
            CurrentCard_Change(card);
            var cardSize = new Point(card.ActualWidth,card.ActualHeight);
            lastImagePositionLeft += 20; // Add a margin of 10 between images
            return card;
        }

        private void Card_CardDragCompleated(object sender, EventArgs e)
        {
            CanvasAdjast();
        }

        private void Card_CardDraging(object sender, DragDeltaEventArgs e)
        {
        }

        // カード : カードのMainCanvas上の位置をチェックしキャンバスのサイズを調整
        public void CanvasAdjast()
        {

            if (CardList.Count <= 0) { return; }

            double scale = MainCanvasTransform.Matrix.M11; // M11 はスケール値

            double maxRight = CardList.Max(card => card.Right);
            double maxBottom = CardList.Max(card => card.Bottom);
            //MainCanvas.Width = maxRight;
            //MainCanvas.Height = maxBottom;
            MainCanvasGrid.Width = maxRight * scale + 30;
            MainCanvasGrid.Height = maxBottom * scale + 30;

        }

        // カード : 選択変更処理
        private void CurrentCard_Change(Card card)
        {
            DeselectCard();
            currentCard = card;
            selectedCardZIndex = card.Z;
            SelectCard(card);
        }

        // カード : 選択解除時のビジュアル処理
        private void DeselectCard()
        {

            if (currentCard != null)
            {
                Effect cardEffect = DefaultCardShadow;
                currentCard.Effect = cardEffect;
                currentCard.CardBorder.BorderBrush = new SolidColorBrush(Colors.Transparent);

                if(SelectedCardShowTopToggleSwitch.IsOn) currentCard.Z = selectedCardZIndex;
                currentCard = null;

            }

        }

        // カード : 選択時のビジュアル処理
        private void SelectCard(Card card)
        {
            if (currentCard != null)
            {
                Effect cardEffect = ShadowToggle.IsOn ? vm.ColorCardShadow : DefaultCardShadow;
                Color borderColor = vm.ShadowColor;
                card.Effect = cardEffect;
                card.CardBorder.BorderBrush = new SolidColorBrush(borderColor);
                card.CardBorder.BorderThickness = new Thickness(1);
                card.CardBorder.Margin = new Thickness(-1);
                currentCard = card;
                if(SelectedCardShowTopToggleSwitch.IsOn) currentCard.Z = 9999;
            }
        }

        // カード : コンテキストメニュー : のEditを選択したときの処理
        private void Card_EditRequested(object sender, EventArgs e)
        {
            if (sender is Card card)
            {
                EditingCard = card;
                EnterEditMode(card);
            }
        }

        // カード : 編集モードに入る際の処理
        private void EnterEditMode(Card card)
        {

            vm.IsInEditMode = true;
            OverrayGrid.Visibility = Visibility.Visible;
            EditingCard = card;
            currentZIndex = card.Z;

            card.BorderBrush = Brushes.LightGray;

            MoveSubWindow(card);
            subWindow.setEditCanvas(card);

        }

        // カード : 編集モードに入る際のSubWindowの移動処理
        private void MoveSubWindow(Card card)
        {
            cardCanvasToggleSwitchLastState_IsOn = CardCanvasVisibleSwitch.IsOn;
            subWindow.Visibility = Visibility.Visible;
            originalSubWindowPos = ConvertDpiScaledPoint(subWindow, subWindow.PointToScreen(new Point(0, 0)));

            var cardCenterPos = ConvertDpiScaledPoint(card, card.CardImage.PointToScreen(new Point(card.ActualWidth / 2, card.ActualHeight / 2)));
            var titlebarHeight = ((Grid)(subWindow.Template.FindName("CustomTitleBar", subWindow))).Height;
            //            subWindow.CardCanvasBorder.BorderBrush = Brushes.Black;

            subWindow.Left = (cardCenterPos.X) - (subWindow.ContentRootGrid.Width / 2);
            subWindow.Top = (cardCenterPos.Y) - (subWindow.ContentRootGrid.Height / 2) - (titlebarHeight);
            
            card.Visibility = Visibility.Hidden;
        }

        // カード : 編集を適用して編集モードを終了する際の処理
        public void FinishEditing(CustomInkCanvas customInkCanvas, ImageSource imageSource, string recogText)
        {
            if (EditingCard == null) return;
            UpdateCard(customInkCanvas, imageSource, recogText);
            OverrayGrid.Visibility = Visibility.Collapsed;
            EditingCard.Visibility = Visibility.Visible;
            RestoreSubWindowPosition();
            EditingCard = null;
            vm.IsInEditMode = false; // 編集モードを終了
        }

        // カード : 編集を破棄して編集モードを終了する際の処理
        public void CancelEditing()
        {
            OverrayGrid.Visibility = Visibility.Collapsed;
            EditingCard.Visibility = Visibility.Visible;
            RestoreSubWindowPosition();
            EditingCard = null;
            vm.IsInEditMode = false;
        }
        private void Card_LayoutUpdated(object sender, EventArgs e)
        {
            
            if(sender is Card card)
            {
                card.LayoutUpdated -= Card_LayoutUpdated;
                RestoreSubWindowPosition();
                EditingCard = null;
            }
        }
        // カード : 編集後にカードを更新
        public void UpdateCard(CustomInkCanvas customInkCanvas, ImageSource imageSource, string recogText)
        {
            //EditingCard.CardInkCanvas.InnerPresenter.StrokeContainer.Clear();
            EditingCard.SetInkCanvas(customInkCanvas.InnerInkCanvas);
            EditingCard.CardImage.Source = imageSource;
            EditingCard.SetText(recogText);
        }

        // カード : 編集モードが終了した際のSubWindowの位置復帰処理
        public void RestoreSubWindowPosition()
        {
            if (!cardCanvasToggleSwitchLastState_IsOn) subWindow.Visibility = Visibility.Collapsed;
            subWindow.CanvasClear();
            subWindow.Left = originalSubWindowPos.X;
            subWindow.Top = originalSubWindowPos.Y;
            //subWindow.CardCanvasBorder.BorderBrush = Brushes.Gray;

        }

        // カード : コンテキストメニュー : のDeleteを選択したときの処理
        private void Card_DeleteRequested(object sender, EventArgs e)
        {
            Card_Delete(sender, EventArgs.Empty);
        }

        // カード : 削除処理
        private void Card_Delete(object sender, EventArgs e)
        {
            if (sender is Card card)
            {
                CardList.Remove(card);
                MainCanvas.Children.Remove(card);
                //                    UpdateCardsList();
            }
        }

        // カード : 選択イベントハンドラー
        private void Card_CardSelected(object sender, EventArgs e)
        {
            var card = sender as Card;
            if (HamburgerMenuPin.IsChecked != true)
                //HamburgerMenu.IsChecked = false;
            CurrentCard_Change(card);
            CardsListView.SelectedItem = card;
        }

        // カード : カードがクリックされたときの処理
        private void Card_Clicked(object sender, EventArgs e)
        {
            var card = sender as Card;
            if (HamburgerMenuPin.IsChecked != true)
            {
                SplitView.IsPaneOpen = false;
                MainScrollViewer.Margin = new Thickness(0);
            }
            CurrentCard_Change(card);
            CardsListView.SelectedItem = card;

        }

        /// <summary>
        /// UWP InkStrokeを拡大縮小などで変換するサンプルメソッド
        /// </summary>
        public InkStroke TransformInkStroke(InkStroke originalStroke, float scaleFactor)
        {
            // 元ストロークのInkPointsを取得
            var points = originalStroke.GetInkPoints();

            // 新しいストロークを作るためのInkStrokeBuilder
            var builder = new InkStrokeBuilder();
            builder.SetDefaultDrawingAttributes(originalStroke.DrawingAttributes);

            // 変換後の座標リストを用意
            var transformedPoints = points.Select(p =>
            {
                double x = p.Position.X * scaleFactor;
                double y = p.Position.Y * scaleFactor;
                return new InkPoint(new Windows.Foundation.Point(x, y), p.Pressure);
            }).ToList();

            // 新しいストロークを作成（PointTransformは自動的に適用）
            return builder.CreateStrokeFromInkPoints(transformedPoints, originalStroke.PointTransform);
        }

        private void TestButton_Click(object sender, RoutedEventArgs e)
        {

            //var cd = card;
            //var cont = card.CardPresenter.StrokeContainer;
            //var mainCont = mainInkCanvas.InnerPresenter.StrokeContainer;
            //foreach (var stroke in mainCont.GetStrokes())
            //{
            //    cont.AddStroke(stroke.Clone());
            //}
        }

        // SplitView : ハンバーガーメニュー : 常に表示ボタンがチェック状態になった時の処理
        private void HamburgerMenuPin_Checked(object sender, RoutedEventArgs e)
        {
            // ピン止めされた場合、SplitViewを表示したままにする

            SplitView.DisplayMode = ui.SplitViewDisplayMode.Inline;
            MainScrollViewer.Margin = new Thickness(300, 0, 0, 0);
            SplitView.IsPaneOpen = true;
        }

        // SplitView : ハンバーガーメニュー : 常に表示ボタンがチェック解除状態になった時の処理
        private void HamburgerMenuPin_Unchecked(object sender, RoutedEventArgs e)
        {
            // ピン止めが解除された場合、SplitViewを通常の動作に戻す
            SplitView.DisplayMode = ui.SplitViewDisplayMode.Overlay;
            SplitView.IsPaneOpen = false;
            MainScrollViewer.Margin = new Thickness(0);

        }

        // SplitView : カードリスト : CardListViewの選択変更イベントハンドラー
        private void CardsListView_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (CardsListView.SelectedItem is Card selectedCard)
            {
                CurrentCard_Change(selectedCard);
            }
        }

        // SplitView : カードリスト : PreviewMouseLeftButtonDown イベントハンドラー
        private void CardsListView_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            _dragStartPoint = e.GetPosition(null);
        }

        // SplitView : カードリスト : MouseMove イベントハンドラー
        private void CardsListView_MouseMove(object sender, MouseEventArgs e)
        {
            if (e.LeftButton == MouseButtonState.Pressed)
            {
                Point currentPosition = e.GetPosition(null);
                Vector diff = _dragStartPoint - currentPosition;

                if (Math.Abs(diff.X) > SystemParameters.MinimumHorizontalDragDistance ||
                    Math.Abs(diff.Y) > SystemParameters.MinimumVerticalDragDistance)
                {
                    if (sender is ui.ListView listView)
                    {
                        // ドラッグするアイテムを取得
                        ui.ListViewItem listViewItem = FindAncestor<ui.ListViewItem>((DependencyObject)e.OriginalSource);
                        if (listViewItem != null)
                        {
                            Card draggedItem = (Card)listView.ItemContainerGenerator.ItemFromContainer(listViewItem);
                            if (draggedItem != null)
                            {
                                DragDrop.DoDragDrop(listViewItem, draggedItem, DragDropEffects.Move);
                            }
                        }
                    }
                }
            }

        }

        // SplitView : カードリスト : DragOver イベントハンドラー
        private void CardsListView_DragOver(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(typeof(Card)))
            {
                e.Effects = DragDropEffects.Move;

                ui.ListView listView = sender as ui.ListView;
                Point position = e.GetPosition(listView);
                Card targetItem = GetItemAtPosition(listView, position);

                // 前回のアドナーを削除
                _insertionAdorner?.Detach();

                bool isInsertionAfter = false;
                ui.ListViewItem adornedElement = null;

                if (targetItem != null)
                {
                    adornedElement = (ui.ListViewItem)listView.ItemContainerGenerator.ContainerFromItem(targetItem);
                    Point itemPosition = adornedElement.TranslatePoint(new Point(0, 0), listView);

                    if (position.Y > itemPosition.Y + adornedElement.ActualHeight / 2)
                    {
                        isInsertionAfter = true;
                    }
                }
                else if (listView.Items.Count > 0)
                {
                    // リストの最後に挿入
                    targetItem = (Card)listView.Items[^1];
                    adornedElement = (ui.ListViewItem)listView.ItemContainerGenerator.ContainerFromItem(targetItem);
                    isInsertionAfter = true;
                }

                if (adornedElement != null)
                {
                    _insertionAdorner = new InsertionAdorner(adornedElement, isInsertionAfter);
                }

                e.Handled = true;
            }
            else
            {
                e.Effects = DragDropEffects.None;
            }
        }

        // SplitView : カードリスト : Drop イベントハンドラー
        private void CardsListView_Drop(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(typeof(Card)))
            {
                Card droppedData = e.Data.GetData(typeof(Card)) as Card;
                ui.ListView listView = sender as ui.ListView;
                Point position = e.GetPosition(listView);
                Card targetItem = GetItemAtPosition(listView, position);

                // アドナーを削除
                _insertionAdorner?.Detach();
                _insertionAdorner = null;

                int removeIndex = CardList.IndexOf(droppedData);
                int targetIndex;

                if (targetItem != null)
                {
                    targetIndex = CardList.IndexOf(targetItem);
                    ui.ListViewItem targetContainer = (ui.ListViewItem)listView.ItemContainerGenerator.ContainerFromItem(targetItem);
                    Point itemPosition = targetContainer.TranslatePoint(new Point(0, 0), listView);

                    if (position.Y > itemPosition.Y + targetContainer.ActualHeight / 2)
                    {
                        targetIndex++;
                    }
                }
                else
                {
                    targetIndex = CardList.Count;
                }

                if (removeIndex != targetIndex)
                {
                    if (removeIndex < targetIndex)
                    {
                        targetIndex--;
                    }
                    CardList.Move(removeIndex, targetIndex);
                }

                UpdateZIndex();
                selectedCardZIndex = targetIndex;
                e.Handled = true;
            }
        }

        // SplitView : カードリスト : ドラッグオーバー時の処理
        private void CardsListView_DragLeave(object sender, DragEventArgs e)
        {
            // アドナーを削除
            _insertionAdorner?.Detach();
            _insertionAdorner = null;
        }

        // SplitView : カードリスト : リストでカードドラッグ後のZIndexの更新
        private void UpdateZIndex()
        {
            var count = CardList.Count - 1;
            for (int i = 0; i < CardList.Count; i++)
            {
                if(CardsListView.Items[i] is Card card)
                {
                    if(card.Z == 9999) {
                        selectedCardZIndex = i;
                    }
                    card.Z = i;
                    //CardList[count - i].Z = i;

                }
            }
            if (SelectedCardShowTopToggleSwitch.IsOn)
            {
               var card = CardList.FirstOrDefault(c => c.Z==selectedCardZIndex) as Card;
                   card.Z = 9999;
            }
            //SortCardListByZIndex();
            CardsListView.InvalidateVisual();
            CardsListView.Items.Refresh();
        }

        // SplitView : カードリスト : リストをZIndexで並べ替え
        private void SortCardListByZIndex()
        {
            // CardList を一時的にリストに変換して並べ替え
            var sortedList = CardList.OrderByDescending(card => card.Z).ToList();

            // CardList をクリアしてから並べ替えたリストを追加
            CardList.Clear();
            foreach (var card in sortedList)
            {
                CardList.Add(card);
            }
        }

        // SplitView : セーブボタン : 新規保存をクリックしたときの処理
        private void SaveAs_Click(object sender, RoutedEventArgs e)
        {
            var saveFileDialog = new Microsoft.Win32.SaveFileDialog
            {
                FileName = vm?.CurrentFileName,
                Filter = "Brain Card files (*.bcf)|*.bcf"
            };

            if (saveFileDialog.ShowDialog() == true)
            {
                if (vm != null)
                {
                    vm.CurrentFileName = saveFileDialog.FileName;
                    vm.IsNewFile = false;
                }

                SaveState(saveFileDialog.FileName);
            }

        }
 
        private void SaveDropDown_Click(ui.SplitButton sender, ui.SplitButtonClickEventArgs args)
        {
            OverWrite_Click(sender, new RoutedEventArgs());

        }

        // SplitView : セーブボタン : 上書きをクリックしたときの処理
        private void OverWrite_Click(object sender, RoutedEventArgs e)
        {

            if (vm != null && vm.IsNewFile)
            {
                SaveAs_Click(sender, e);
                return;
            }

            SaveState(vm?.CurrentFileName);
            StatusBarMessageTextBlock.Text = "上書き保存しました。";
            StatusbarTimer_start();
        }

        // SplitView : セーブボタン : 現在の状態を保存します。
        private void SaveState(string filename)
        {
            if (string.IsNullOrWhiteSpace(filename)) return;

            List<SavedImage> savedImages = new List<SavedImage>();
            foreach (var child in CardList)
            {
                if (child is Card card)
                {
                    var serializedStrokes = SerializeStrokes(card.CardInkCanvas.InnerPresenter);
                    var savedImage = new SavedImage
                    {
                        Id = string.IsNullOrWhiteSpace(card.Id) ? Guid.NewGuid().ToString("N") : card.Id,
                        X = card.Left,
                        Y = card.Top,
                        Z = card.Z,
                        RecogText = card.RecognizedText,
                        InkData = serializedStrokes.Result
                    };
                    card.Id = savedImage.Id;
                    savedImages.Add(savedImage);

                    var pngPath = GetCardPngPath(filename, savedImage.Id);
                    if (pngPath != null && card.CardImage?.Source is BitmapSource bmp)
                    {
                        SavePng(pngPath, bmp);
                    }
                }
            }

            string json = JsonConvert.SerializeObject(savedImages, Newtonsoft.Json.Formatting.Indented);
            File.WriteAllText(filename, json);

            // ファイルの状態を更新します（ウィンドウタイトルは ViewModel のプロパティにバインドされています）。
            if (vm != null)
            {
                vm.CurrentFileName = filename;
                vm.IsNewFile = false;
            }

            StatusBarMessageTextBlock.Text = "保存しました。";
            StatusbarTimer_start();
        }

        // SplitView : セーブボタン : InkPresenterをJson文字列に変換
        private async Task<string> SerializeStrokes(Windows.UI.Input.Inking.InkPresenter presenter)
        {
            var container = presenter.StrokeContainer;
            using MemoryStream ms = new MemoryStream();
            using IRandomAccessStream stream = ms.AsRandomAccessStream();
            await container.SaveAsync(stream);
            var isf = ms.ToArray();
            // StrokeCollectionData を JSON にシリアル化
            string json = JsonConvert.SerializeObject(isf);
            return json;
        }

        // SplitView : ロードボタン : クリックしたときの処理
        private void LoadButton_Click(object sender, RoutedEventArgs e)
        {
            var openFileDialog = new Microsoft.Win32.OpenFileDialog
            {
                Filter = "Brain Card files (*.bcf)|*.bcf"
            };

            if (openFileDialog.ShowDialog() == true)
            {
                if (vm != null)
                {
                    vm.CurrentFileName = openFileDialog.FileName;
                    vm.IsNewFile = false;
                }

                _ = LoadStateAsync(openFileDialog.FileName);
                
            }
        }

        // SplitView : ロードボタン : 保存した状態をロードします。
        private Task LoadStateAsync(string filename)
        {
            // UIイベントからも呼べるよう、例外を握りつぶさずTaskとして返す
            return LoadStateCoreAsync(filename);
        }

        // 実体のロード処理（await前提）
        private async Task LoadStateCoreAsync(string filename)
        {
            if (!File.Exists(filename)) return;

            // 多重ロードを防止
            await _loadSemaphore.WaitAsync();
            SetLoadingUi(true, "LoadingMessage");

            try
            {
                // Update file state (Title is bound).
                if (vm != null)
                {
                    vm.CurrentFileName = filename;
                    vm.IsNewFile = false;
                }

                currentZIndex = 0;
                lastImagePositionLeft = 0;
                lastImagePositionTop = 0;
                CardList.Clear();
                MainCanvas.Children.Clear();

                // ストローク復元中のちらつきを防ぐ
                var prevHostVisibility = subWindow.CardInkCanvasHost?.Visibility ?? Visibility.Visible;
                if (subWindow.CardInkCanvasHost != null)
                {
                    subWindow.CardInkCanvasHost.Visibility = Visibility.Collapsed;
                }
                
                string json = File.ReadAllText(filename);
                var savedImages = JsonConvert.DeserializeObject<List<SavedImage>>(json);

                try
                {
                    foreach (SavedImage savedImage in savedImages)
                    {
                        // 後方互換: Idが無い場合は付与
                        if (string.IsNullOrWhiteSpace(savedImage.Id))
                        {
                            savedImage.Id = Guid.NewGuid().ToString("N");
                        }

                        var cachedPngPath = GetCardPngPath(filename, savedImage.Id);
                        ImageSource imageSource = TryLoadPng(cachedPngPath);

                        // カスタムInkCanvasを作成し、ストロークを設定
                        CustomInkCanvas customInkCanvas = subWindow.customInkCanvas;
                        var innerInkCanvas = customInkCanvas.InnerInkCanvas;
                        var resizeInkCanvas = subWindow.resizeInkCanvas;

                        // ストロークデータを復元
                        innerInkCanvas.InkPresenter.StrokeContainer = await DeserializeStrokes(savedImage.InkData);

                        if (imageSource == null)
                        {
                            resizeInkCanvas.SetInnerCanvas(innerInkCanvas);
                            resizeInkCanvas.UpdateLayout();

                            var renderTargetBitmap = new Windows.UI.Xaml.Media.Imaging.RenderTargetBitmap();
                            await renderTargetBitmap.RenderAsync(resizeInkCanvas.InnerInkCanvas);

                            var pixelBuffer = await renderTargetBitmap.GetPixelsAsync();
                            byte[] pixels = pixelBuffer.ToArray();
                            int width = renderTargetBitmap.PixelWidth;
                            int height = renderTargetBitmap.PixelHeight;
                            var dpi = VisualTreeHelper.GetDpi(this).DpiScaleX;

                            var wb = new System.Windows.Media.Imaging.WriteableBitmap(width, height, dpi, dpi, PixelFormats.Bgra32, null);
                            wb.Lock();
                            wb.WritePixels(new Int32Rect(0, 0, width, height), pixels, width * 4, 0);
                            wb.Unlock();
                            imageSource = wb;

                            if (cachedPngPath != null)
                            {
                                SavePng(cachedPngPath, wb);
                            }
                        }

                        // カードを復元
                        var card = AddCard(customInkCanvas, imageSource, savedImage.RecogText, savedImage.X, savedImage.Y, AddMode.Load);
                        card.Id = savedImage.Id;
                    }
                }
                finally
                {
                    if (subWindow.CardInkCanvasHost != null)
                    {
                        subWindow.CardInkCanvasHost.Visibility = prevHostVisibility;
                    }
                }
 
             // Zインデックスを再設定
             UpdateZIndex();

             // キャンバスの表示を更新
             MainCanvas.InvalidateVisual();
             CardsLoaded?.Invoke(this, EventArgs.Empty);
             subWindow.CanvasClear();
         }
         finally
         {
            SetLoadingUi(false);
            _loadSemaphore.Release();
         }
        }

        // SplitView : ロードボタン : Json文字列をInkStrokeContainerに変換
        private async Task<InkStrokeContainer> DeserializeStrokes(string json)
        {
            var isfData = JsonConvert.DeserializeObject<byte[]>(json);
            using var ms = new MemoryStream(isfData);
            using var stream = ms.AsRandomAccessStream();

            var container = new InkStrokeContainer();
            await container.LoadAsync(stream); 
            return container;
        }

        // SplitView : クリアボタン : クリックしたときの処理
        private void ClearAllButton_Click(object sender, RoutedEventArgs e)
        {
            MainCanvas.Children.Clear();
            CardList.Clear();
            CardsListView.InvalidateVisual();
            CardsListView.Items.Refresh();
            currentZIndex = 0;
        }

        // SplitView : 入力ウィンドウトグルスイッチ : スイッチの状態が変更されたときの処理
        private void CardCanvasVisibleSwitch_Toggled(object sender, RoutedEventArgs e)
        {
            var toggleButton = sender as ui.ToggleSwitch;
            if (subWindow != null)
            {
                if (toggleButton.IsOn)
                {
                    subWindow.Visibility = System.Windows.Visibility.Visible;
                    subWindow.Top = vm.SubWindowPosition.Y;
                    subWindow.Left = vm.SubWindowPosition.X;
                    vm.SubwindowVisible = true;
                }
                else
                {
                    var pos = new Point(subWindow.Left, subWindow.Top);
                    vm.SubWindowPosition = pos;
                    vm.SubwindowVisible = false;
                    subWindow.Visibility = System.Windows.Visibility.Hidden;

                }
            }
        }

        // SplitView : 言語選択コンボックス : 言語変更イベントハンドラー
        private void LanguageSelector_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (LanguageSelector.SelectedItem is ComboBoxItem selectedItem)
            {
                string selectedCulture = selectedItem.Tag.ToString();
                ChangeLanguage(selectedCulture);
            }

        }

        // SplitView : 言語選択コンボックス : 言語を変更するメソッド
        private void ChangeLanguage(string cultureName)
        {
            // カルチャを変更
            Thread.CurrentThread.CurrentCulture = new CultureInfo(cultureName);
            Thread.CurrentThread.CurrentUICulture = new CultureInfo(cultureName);

            // リソースを再読み込み
            //ReloadResources();

            if (string.IsNullOrEmpty(cultureName))
                return;

            try
            {
                CultureInfo newCulture = new CultureInfo(cultureName);

                // 現在の言語と異なる場合のみ更新
                if (!Equals(Language, XmlLanguage.GetLanguage(newCulture.IetfLanguageTag)))
                {
                    // MainWindowのLanguageプロパティを更新
                    Language = XmlLanguage.GetLanguage(newCulture.IetfLanguageTag);

                    // アプリケーション全体のリソースを更新 (必要であれば)
                    ResourceDictionary langDict = new ResourceDictionary();
                    try
                    {
                        langDict.Source = new Uri($"pack://application:,,,/Properties/Resources.{Thread.CurrentThread.CurrentUICulture.Name}.xaml", UriKind.Absolute);
                        // 既存のリソースディクショナリを置き換える
                        int existingLangDictIndex = -1;
                        for (int i = 0; i < Resources.MergedDictionaries.Count; i++)
                        {
                            if (Resources.MergedDictionaries[i].Source != null && Resources.MergedDictionaries[i].Source.OriginalString.StartsWith("pack://application:,,,/Properties/Resources."))
                            {
                                existingLangDictIndex = i;
                                break;
                            }
                        }
                        if (existingLangDictIndex > -1)
                        {
                            Resources.MergedDictionaries.RemoveAt(existingLangDictIndex);
                        }
                        Resources.MergedDictionaries.Add(langDict);
                        if (vm != null)
                        {
                            vm.StringsResourceDictionary.Clear();
                            vm.StringsResourceDictionary.MergedDictionaries.Add(langDict);
                        }

                    }
                    catch (Exception ex)
                    {
                        // リソースファイルが見つからない場合などのエラー処理
                        Console.WriteLine($"Error loading language resource: {ex.Message}");
                    }
                }
            }
            catch (CultureNotFoundException)
            {
                Console.WriteLine($"Culture '{cultureName}' not found.");
            }
            // 必要に応じてウィンドウを再初期化
            // ReloadWindow();
            // コントロールの内容を更新
            UpdateControlContent();
        }

        // SplitView : 言語選択コンボックス : コントロールの内容を更新するメソッド
        private void UpdateControlContent()
        {
            if (CardList is null) return;
            foreach (var card in CardList)
            {
                if(card.ContextMenu is ContextMenu menu)
                {
                    foreach(MenuItem item in menu.Items)
                    {
                        switch (item.Name)
                        {
                            case "MenuEdit":
                                item.SetResourceReference(MenuItem.HeaderProperty, "ContextMenuEditHeader");

                                break;
                            case "MenuDelete":
                                item.SetResourceReference(MenuItem.HeaderProperty, "ContextMenuDeleteHeader");
                                break;
                        }
                    }
                }
            }
            
            foreach (var listItem in CardsListView.Items)
            {
                if (listItem is ListViewItem listitem)
                {
                    var container = CardsListView.ItemContainerGenerator.ContainerFromItem(listItem) as ModernWpf.Controls.ListViewItem;
                    if (container?.ContextMenu is ContextMenu contextMenu)
                    {
                        foreach (MenuItem item in contextMenu.Items)
                        {
                            switch (item.Name)
                            {
                                case "ContextMenuEdit":
                                    item.SetResourceReference(MenuItem.HeaderProperty, "ContextMenuEditHeader");
                                    break;
                                case "ContextMenuDelete":
                                    item.SetResourceReference(MenuItem.HeaderProperty, "ContextMenuDeleteHeader");
                                    break;
                            }
                        }
                    }
                    
                }
            }
            CardsListView.Items.Refresh();
            
            // 各コントロールのプロパティを更新
            // 例：
            //BackButton.Content = Properties.Resources.BackButtonContent;
            //FrontButton.Content = Properties.Resources.FrontButtonContent;
            // 他のコントロールも同様に更新
        }

        // SplitView : イメージスケール : スライダーの値変更イベント スケーリングの変更・更新
        private void ImageScaleSlider_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            if (MainCanvasTransform is null) return;
            // ToDo : 拡大縮小中心位置の調整（マウスホイール使用時とスライダー使用時の挙動）
            var scale = ImageScaleSlider.Value / 100;
            double prevScale = oldScale;
            double offsetX;
            double offsetY;
            ScaleTransform transform;
            {
                if (currentCard != null)
                {
                    Debug.WriteLine("CurrentCard != null : isWheelScaling == false");
                    var card = currentCard;
                    var cardCenterX = Canvas.GetLeft(card) + card.ActualWidth / 2;
                    var cardCenterY = Canvas.GetTop(card) + card.ActualHeight / 2;
                    transform = new ScaleTransform(scale, scale, cardCenterX, cardCenterY);

                    offsetX = (cardCenterX * scale) - (cardCenterX * prevScale);
                    offsetY = (cardCenterY * scale) - (cardCenterY * prevScale);
                }
                else
                {
                    if (isWheelScaling)
                    {
                        Debug.WriteLine("CurrentCard == null : isWheelScaling == true");
                        var cwp = mouseCanvasPos;
                        transform = new ScaleTransform(scale, scale, cwp.X, cwp.Y);

                        offsetX = cwp.X * scale - cwp.X * prevScale;
                        offsetY = cwp.Y * scale - cwp.Y * prevScale;
                    }
                    else
                    {
                        Debug.WriteLine("CurrentCard == null : isWheelScaling == false");
                        var centerX = MainScrollViewer.HorizontalOffset + MainScrollViewer.ViewportWidth / 2;
                        var centerY = MainScrollViewer.VerticalOffset + MainScrollViewer.ViewportHeight / 2;
                        transform = new ScaleTransform(scale, scale, centerX, centerY);

                        offsetX = (centerX * scale) - (centerX * prevScale);
                        offsetY = (centerY * scale) - (centerY * prevScale);
                    }
                }
            }
            MainCanvasTransform.Matrix = transform.Value;
            MainScrollViewer.ScrollToHorizontalOffset(MainScrollViewer.HorizontalOffset + offsetX);
            MainScrollViewer.ScrollToVerticalOffset(MainScrollViewer.VerticalOffset + offsetY);
            MainCanvasGrid.Width = MainCanvas.ActualWidth * scale;
            MainCanvasGrid.Height = MainCanvas.ActualHeight * scale;
            CanvasAdjast();
            // ステータスバーにメッセージを表示
            StatusBarMessageTextBlock.Text = $"{ImageScaleSlider.Value}%";
            StatusbarTimer_start(5);

            isWheelScaling = false;
            oldScale = scale;
        }

        // SplitView : カードの影の設定 : シャドウの設定を変更
        private void Slider_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            if (vm is null) return;
            if (sender is Slider slider)
            {
                switch (slider.Name)
                {
                    case "ImageScaleSlider":
                        ImageScaleSlider_ValueChanged(sender, e);
                        break;
                }

                if(currentCard != null && slider.Name != "ImageScaleSlider")
                    SelectCard(currentCard);
            }
            e.Handled = true;
        }
        //　SplitView : スライダーのマウスホイール操作による値変更
        private void Slider_PreviewMouseWheel(object sender, MouseWheelEventArgs e)
        {
            if (sender is Slider slider)
            {
                var step = slider.LargeChange;
                if (currentCard != null && slider.Name != "ImageScaleSlider") SelectCard(currentCard);
                if (e.Delta > 0)
                        slider.Value += step * e.Delta / 120;
                else
                        slider.Value += step * e.Delta / 120;
            }
            e.Handled = true;
        }

        // ロード中オーバーレイの表示/非表示を切り替える
        private void SetLoadingUi(bool isLoading, string messageResourceKey = null)
        {
            if (vm == null) return;

            vm.IsLoading = isLoading;
            if (!string.IsNullOrWhiteSpace(messageResourceKey))
            {
                // リソースキーからメッセージを取得
                if (TryFindResource(messageResourceKey) is string msg)
                {
                    vm.LoadingMessage = msg;
                }
                else
                {
                    vm.LoadingMessage = messageResourceKey;
                }
            }
            else if (isLoading)
            {
                // 既定メッセージ
                if (TryFindResource("LoadingMessage") is string msg)
                {
                    vm.LoadingMessage = msg;
                }
                else
                {
                    vm.LoadingMessage = "ロード中…";
                }
            }

            OverrayGrid.Visibility = isLoading ? Visibility.Visible : Visibility.Hidden;
            Mouse.OverrideCursor = isLoading ? Cursors.Wait : null;
        }

        // ヘルパーメソッド：指定位置のアイテムを取得
        private Card GetItemAtPosition(ui.ListView listView, Point position)
        {
            HitTestResult result = VisualTreeHelper.HitTest(listView, position);
            DependencyObject obj = result?.VisualHit;

            while (obj != null && obj != listView)
            {
                if (obj is ui.ListViewItem item)
                {
                    return (Card)listView.ItemContainerGenerator.ItemFromContainer(item);
                }
                obj = VisualTreeHelper.GetParent(obj);
            }
            return null;
        }

        // ヘルパーメソッド：指定した型の親要素を取得
        private static T FindAncestor<T>(DependencyObject current) where T : DependencyObject
        {
            while (current != null && !(current is T))
            {
                current = VisualTreeHelper.GetParent(current);
            }
            return current as T;
        }

        // ヘルパーメソッド : 指定した名前の子要素を取得
        private static T FindChild<T>(DependencyObject parent, string childName) where T : DependencyObject
        {
            if (parent == null) return null;
            T foundChild = null;
            int childrenCount = VisualTreeHelper.GetChildrenCount(parent);
            for (int i = 0; i < childrenCount; i++)
            {
                var child = VisualTreeHelper.GetChild(parent, i);
                if (!(child is T t))
                {
                    foundChild = FindChild<T>(child, childName);
                    if (foundChild != null) break;
                }
                else if (!string.IsNullOrEmpty(childName))
                {
                    if (child is FrameworkElement frameworkElement && frameworkElement.Name == childName)
                    {
                        foundChild = t;
                        break;
                    }
                }
                else
                {
                    foundChild = t;
                    break;
                }
            }
            return foundChild;
        }

        // ヘルパーメソッド : ステータスバーメッセージ消去用タイマー
        private void StatusbarTimer_start(int interval = 5)
        {
            StatusBarMessageClearTimer = new DispatcherTimer { Interval = TimeSpan.FromSeconds(interval) };
            StatusBarMessageClearTimer.Tick += StatusBarMessageClearTimer_Tick;
            StatusBarMessageClearTimer.Start();
        }
        private void StatusBarMessageClearTimer_Tick(object sender, EventArgs e)
        {
            StatusBarMessageTextBlock.Text = "";
            StatusBarMessageClearTimer.Stop();
            StatusBarMessageClearTimer.Tick -= StatusBarMessageClearTimer_Tick;

        }


        // タッチ操作時の位置情報記憶用グローバル変数
        private double initialDistance;
        private double initialImageSliderValue;

        // タッチ操作によるズーム処理
        private void Touch_FrameReported(object sender, TouchFrameEventArgs e)
        {
        
            if (e.GetTouchPoints(null).Count == 2)
            {
                TouchPoint touchPoint1 = e.GetPrimaryTouchPoint(null);
                TouchPoint touchPoint2 = e.GetTouchPoints(null)[1];
                if (touchPoint1.Action == TouchAction.Down || touchPoint2.Action == TouchAction.Down)
                {
                    // ズーム操作開始時の2点間の距離とズームスライダーの値をグローバル変数に記録
                    initialDistance = GetDistance(touchPoint1.Position, touchPoint2.Position);
                    initialImageSliderValue = ImageScaleSlider.Value;
                }
                else if (touchPoint1.Action == TouchAction.Move || touchPoint2.Action == TouchAction.Move)
                {
                    // ズーム操作中の2点間の距離をグローバル変数から取得し、ズームスライダーの値を更新
                    double currentDistance = GetDistance(touchPoint1.Position, touchPoint2.Position);
                    double scale = currentDistance / initialDistance;

                    ImageScaleSlider.Value = initialImageSliderValue * scale;
                    
                }
            }

        }

        // 2点間の距離を取得（指によるピンチ・ズームに使用？）
        private double GetDistance(System.Windows.Point point1, System.Windows.Point point2)
        {
            double xDiff = point1.X - point2.X;
            double yDiff = point1.Y - point2.Y;
            return Math.Sqrt(xDiff * xDiff + yDiff * yDiff);
        }


        // MainWindowの背景色を変更する
        private void ColorPicker_SelectedColorChanged(object sender, ColorChangedEventArgs e)
        {
            if (e.SelectedColor is Color selectedColor)
            {
                // 選択された色を使用して処理を行う（例：背景色を変更）
                MainCanvasGrid.Background = new SolidColorBrush(selectedColor);
                MainScrollViewer.Background = new SolidColorBrush(selectedColor);
            }
        }

        // カード : カードの位置を変換
        /// <summary>
        /// カード : カードの位置を変換
        /// 指定されたポイントをDPIスケールに基づいて変換する役割を果たしています。
        /// 異なるDPI設定のディスプレイ間でポイントの位置を正確に変換するために使用。
        /// obj は、変換元のオブジェクト（MainWindow、Card、SubWindow）を指定します。
        /// </summary>
        /// <param name="obj"></param>
        /// <param name="point"></param>
        /// <returns></returns>
        public Point ConvertDpiScaledPoint(object obj, Point point)
        {
            Window window = obj switch
            {
                MainWindow mainWindow => mainWindow,
                Card _ => this,
                SubWindow subWindow => subWindow,
                _ => null,
            };
            var systemDisplayScale = VisualTreeHelper.GetDpi(window).DpiScaleX;
            var convertedPoint = new Point(point.X / systemDisplayScale, point.Y / systemDisplayScale);
            return convertedPoint;
        }


        /// <summary>
        /// ShadowColorPickerButton の ColorChanged イベントハンドラー。
        /// ビューモデルの ShadowColor プロパティを更新し、現在選択されているカードのビジュアルを更新します。
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void ShadowColorPickerButton_ColorChanged(object sender, ColorChangedEventArgs e)
        {
            if (vm is null) return;
            vm.ShadowColor = e.SelectedColor;
            SelectCard(currentCard);
        }

        private void SelectedCardShowTopToggleSwitch_Toggled(object sender, RoutedEventArgs e)
        {
            if(currentCard is null) return;
            if (SelectedCardShowTopToggleSwitch.IsOn)
            {
                SelectCard(currentCard);
            }
            else
            {
                currentCard.Z= selectedCardZIndex;
                SelectCard(currentCard);
            }
        }

        private void ShadowToggle_Toggled(object sender, RoutedEventArgs e)
        {
            if (currentCard is null) return;
            SelectCard(currentCard);

        }

        private void OverrayGrid_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            // ロード中は入力抑止のため何もしない
            if (vm?.IsLoading == true) return;

            if (vm.IsInEditMode)
            {
                CancelEditing();
            }
        }

        private void DebugModeSwitch_Toggled(object sender, RoutedEventArgs e)
        {
            var debugSwitch = sender as ModernWpf.Controls.ToggleSwitch;
            if (debugSwitch.IsOn)
            {
                subWindow.testPict.Visibility = Windows.UI.Xaml.Visibility.Visible;
                vm.TestPictVisible = Visibility.Visible;
                vm.DebugTextVisible = Visibility.Visible;
                CardsListView.InvalidateVisual();
                CardsListView.Items.Refresh();

            }
            else
            {
                subWindow.testPict.Visibility = Windows.UI.Xaml.Visibility.Collapsed;
                vm.TestPictVisible = Visibility.Hidden;
                vm.DebugTextVisible = Visibility.Collapsed;
                CardsListView.InvalidateVisual();
                CardsListView.Items.Refresh();

            }
        }

        private void MenuItem_Click(object sender, RoutedEventArgs e)
        {

        }

        private void ContextMenuEdit_Click(object sender, RoutedEventArgs e)
        {
            if (currentCard != null )
            {
                EditingCard = currentCard;
                EnterEditMode(currentCard);
            }

        }

        private void ContextMenuDelete_Click(object sender, RoutedEventArgs e)
        {
            Card_Delete(currentCard, EventArgs.Empty);
        }

        private void CardsListView_PreviewMouseRightButtonUp(object sender, MouseButtonEventArgs e)
        {
            Point currentPosition = e.GetPosition(null);
            Vector diff = _dragStartPoint - currentPosition;

            if (Math.Abs(diff.X) > SystemParameters.MinimumHorizontalDragDistance ||
                Math.Abs(diff.Y) > SystemParameters.MinimumVerticalDragDistance)
            {
                if (sender is ui.ListView)
                {
                    // ドラッグするアイテムを取得
                    ui.ListViewItem listViewItem = FindAncestor<ui.ListViewItem>((DependencyObject)e.OriginalSource);
                    if (listViewItem == null)
                        e.Handled = true;
                }
            }

        }

        private void MenuOpenRectangle_MouseEnter(object sender, MouseEventArgs e)
        {
            SplitView.DisplayMode = ui.SplitViewDisplayMode.Inline;
            SplitView.IsPaneOpen = true;
        }

        private void MenuOpenRectangle_GotMouseCapture(object sender, MouseEventArgs e)
        {
            SplitView.DisplayMode = ui.SplitViewDisplayMode.Inline;
            SplitView.IsPaneOpen = true;
        }


        private void GridSplitter_DragDelta(object sender, DragDeltaEventArgs e)
        {
            if (SplitView.OpenPaneLength + e.HorizontalChange > 250)
            SplitView.OpenPaneLength += e.HorizontalChange;
            e.Handled = true;
        }

        private void Vm_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e == null) return;

            // Shadow parameter change regenerates vm.ColorCardShadow; refresh selected card.
            if (e.PropertyName == nameof(MainWindowViewModel.ColorCardShadow) ||
                e.PropertyName == nameof(MainWindowViewModel.ShadowBlurRadius) ||
                e.PropertyName == nameof(MainWindowViewModel.ShadowDepth) ||
                e.PropertyName == nameof(MainWindowViewModel.ShadowDirection) ||
                e.PropertyName == nameof(MainWindowViewModel.ShadowOpacity) ||
                e.PropertyName == nameof(MainWindowViewModel.ShadowColor))
            {
                if (currentCard != null)
                {
                    SelectCard(currentCard);
                }
            }
        }

        private static string GetAssetsDirectory(string bcfPath)
        {
            if (string.IsNullOrWhiteSpace(bcfPath)) return null;
            return bcfPath + ".Assets";
        }

        private static string GetCardPngPath(string bcfPath, string cardId)
        {
            var assetsDir = GetAssetsDirectory(bcfPath);
            if (string.IsNullOrWhiteSpace(assetsDir) || string.IsNullOrWhiteSpace(cardId)) return null;
            return System.IO.Path.Combine(assetsDir, $"{cardId}.png");
        }

        private static BitmapImage TryLoadPng(string filePath)
        {
            try
            {
                if (string.IsNullOrWhiteSpace(filePath) || !File.Exists(filePath)) return null;

                var bmp = new BitmapImage();
                bmp.BeginInit();
                bmp.CacheOption = BitmapCacheOption.OnLoad;
                bmp.UriSource = new Uri(filePath, UriKind.Absolute);
                bmp.EndInit();
                bmp.Freeze();
                return bmp;
            }
            catch
            {
                return null;
            }
        }

        private static void SavePng(string filePath, BitmapSource source)
        {
            if (string.IsNullOrWhiteSpace(filePath) || source == null) return;

            var dir = System.IO.Path.GetDirectoryName(filePath);
            if (!string.IsNullOrWhiteSpace(dir))
            {
                Directory.CreateDirectory(dir);
            }

            var encoder = new PngBitmapEncoder();
            encoder.Frames.Add(BitmapFrame.Create(source));
            using var fs = new FileStream(filePath, FileMode.Create, FileAccess.Write, FileShare.Read);
            encoder.Save(fs);
        }

    }


    public enum AddMode
    {
        Cleate,
        Load
    }

    public class PaneWidthConverter : IValueConverter
    {
        public object Convert (Object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is double contentWidth)
            {
                return contentWidth + 10;
            }
            return false;
        }
        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return null;
        }

    }

    public class VisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            /// <summary>
            /// bool 値を Visibility に変換します。
            /// true → Visible、false → Collapsed
            /// </summary>
            if (value is bool booleanValue)
            {
                var v = booleanValue ? Visibility.Visible : Visibility.Collapsed;
                return v;
            }
            return Visibility.Collapsed;
        }

        /// <summary>
        /// Visibility を bool 値に変換します。
        /// Visible → true、その他 → false
        /// </summary>
        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is Visibility visibility)
            {
                return visibility == Visibility.Visible;
            }
            return false;
        }

    }
    // シリアライズ可能なクラスにデータコントラクト属性を付与
    [DataContract]
    public class SavedImage
    {
        [DataMember]
        public string Id {  get; set; }

        [DataMember]
        public double X { get; set; }
        [DataMember]
        public double Y { get; set; }
        [DataMember]
        public int Z { get; set; }
        [DataMember]
        public string RecogText { get; set; }
        [DataMember]
        public string InkData { get; set; } // ストロークデータをBase64文字列で保存
    }

    [DataContract]
    public class StrokeData
    {
        [DataMember]
        public byte[] IsfData { get; set; }

        [DataMember]
        public Brush StrokeBrush { get; set; }
    }

    [DataContract]
    public class StrokeCollectionData
    {
        [DataMember]
        public List<StrokeData> Strokes { get; set; } = new List<StrokeData>();
        }

    public class SplitViewPaneRootListViewWidthConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is double doubleValue && parameter is string parameterString && double.TryParse(parameterString, out double subtractValue))
            {
                return doubleValue - subtractValue;
            }
            return value;
        }
        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is double doubleValue && parameter is string parameterString && double.TryParse(parameterString, out double subtractValue))
            {
                return doubleValue + subtractValue;
            }
            return value;
        }
    }
}
public class InsertionAdorner : Adorner
{
    private readonly bool _isInsertionAfter;
    private readonly FrameworkElement _adornedElement;
    private readonly AdornerLayer _adornerLayer;

    public InsertionAdorner(FrameworkElement adornedElement, bool isInsertionAfter)
        : base(adornedElement)
    {
        _adornedElement = adornedElement;
        _isInsertionAfter = isInsertionAfter;
        _adornerLayer = AdornerLayer.GetAdornerLayer(_adornedElement);
        _adornerLayer.Add(this);
    }

    protected override void OnRender(DrawingContext drawingContext)
    {
        base.OnRender(drawingContext);

        Rect rect = new Rect(_adornedElement.RenderSize);
        Point startPoint;
        Point endPoint;

        if (_isInsertionAfter)
        {
            startPoint = new Point(rect.Left, rect.Bottom);
            endPoint = new Point(rect.Right, rect.Bottom);
        }
        else
        {
            startPoint = new Point(rect.Left, rect.Top);
            endPoint = new Point(rect.Right, rect.Top);
        }

        Pen pen = new Pen(Brushes.DarkGray, 2);
        drawingContext.DrawLine(pen, startPoint, endPoint);
    }

    public void Detach()
    {
        _adornerLayer.Remove(this);
    }
}